-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/progala2/Story-Teller-Engine/blob/master/README.md</a>
@package Story-Teller-Engine
@version 0.7.0.0


module Extensions.Console
clearScreen :: IO ()

-- | Clear a console and write the provided string in red color.
printError :: String -> IO ()

-- | Clear a console and write the provided string in blue color.
printMessage :: String -> IO ()
printColored :: Color -> String -> IO ()

-- | Print a message to the console and wait for input from an user. It is
--   the same as
--   
--   <pre>
--   putStrLn str &gt;&gt; getLine 
--   </pre>
askForLine :: String -> IO String

-- | Print a multiline message to the console and wait for input from an
--   user.
askMlForLine :: [String] -> IO String

-- | Works as the <a>putStrLn</a> function but text is writen one char per
--   given miliseconds.
putStrLnLazy :: Int -> String -> IO ()


module Extensions.Errors

-- | Throws an error with "This scenario can't happen." message.
errCant :: b


module Extensions.Monad

-- | Take Just value or throw an error.
takeJust :: Maybe a -> a

-- | Convert table of Eithers to one Either with table of values.
--   
--   The result will be Left if there is at least one Left in the initial
--   table. String from the Left value will provide all the Lefts values
--   found during mapping.
rightsIfAll :: [Either String b] -> Either String [b]

-- | It is the same as writting:
--   
--   <pre>
--    fmap fmap fmap
--   or
--    (f <a>$</a>) <a>$</a> g
--   </pre>
(<$$>) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)

-- | It is a helper to avoid writing:
--   
--   <pre>
--   &gt;&gt;&gt; f &lt;*&gt; pure a
--   </pre>
(<.>) :: Applicative f => f (a -> b) -> a -> f b
infixl 4 <.>

-- | Returns <tt>a ()</tt> if <a>True</a>, or <tt>return ()</tt> if
--   <a>False</a>.
ifdM :: Monad a => a () -> Bool -> a ()

-- | Returns <tt>a ()</tt> if <a>False</a>, or <tt>return ()</tt> if
--   <a>True</a>.
ifdrM :: Monad a => a () -> Bool -> a ()


module Extensions.Parsec

-- | The same as <a>manyTill</a> but at least one <tt>a</tt> is parsed.
manyTill1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]

-- | Very similar to <a>space</a> but without new lines charactes.
spaceb :: CharParser () Char

-- | Very similar to <a>spaces</a> but without new lines charactes.
spacebs :: CharParser () String

-- | The same as <a>spacebs</a> but discards any results.
spacebs' :: CharParser () ()

-- | Read the end of line.
eol :: CharParser () String

-- | As <a>eol</a> but discards any results.
eol' :: CharParser () ()

-- | Parse all spacesbs until the end of line that it also read.
spacebsAndEol' :: CharParser () ()

-- | Parse between spacebs. Spacebs are discarded and only the result of
--   the given parser is returned.
btwnSpacebs :: CharParser () a -> CharParser () a

-- | <pre>
--   &gt;&gt;&gt; 'many1' 'letter'
--   </pre>
letters1 :: CharParser () String

-- | <pre>
--   &gt;&gt;&gt; 'many1' 'spaceb'
--   </pre>
spacebs1 :: CharParser () String

-- | Parsing with trying to use one of the given strings. Very similar to
--   <a>choice</a>.
choiceString :: [String] -> CharParser () String

-- | Parse a string with spacebs between. End parsing when there is no more
--   letters after spacebs or the charactes is different than letter.
stringSpacebs :: CharParser () String

-- | Parse <tt>'</tt> and discards spacebs around it.
sQuotaBtwnSpacebs :: CharParser () String


-- | It is used to convert data to string that is without unnecessary
--   constructots names. Only pure strings for user-friendliness.
module Game.RealShow
class RealShow a
rShow :: RealShow a => a -> String
instance Game.RealShow.RealShow a => Game.RealShow.RealShow [a]


-- | All the data regarding the game is located here with some basic
--   functions on them.
module Game.GameState

-- | <tt>StateT</tt> <a>IO</a> monad with <a>GameStatus</a>
type GameStateIO a = StateT GameStatus IO a

-- | <tt>StateT</tt> monad with <a>GameStatus</a>
type GameStateM m a = StateT GameStatus m a

-- | Helper for taking only locations data (<a>LocationP</a>,
--   <a>LocMap</a>) from <a>GameStatus</a>.
getLocations :: Monad m => GameStateM m (LocationP, LocMap)

-- | Helper for taking the current location of the player from
--   <a>GameStatus</a>.
getCurrLocation :: Monad m => GameStateM m Location

-- | Helper for taking only <a>PlayerStatus</a> data from
--   <a>GameStatus</a>.
getPlayerStatus :: Monad m => GameStateM m PlayerStatus

-- | Helper for taking only <a>GameOptions</a> data from <a>GameStatus</a>.
getGo :: Monad m => GameStateM m GameOptions
getCurrLocUniqueActionsNames :: Monad m => GameStateM m [[String]]

-- | Provide the whole description of the <a>Location</a> the player is in,
--   taking <a>Condition</a>s into consideration if necessary. if
--   <a>Condition</a> for description of the current <a>Location</a> is not
--   met it will not be added to the result.
showDescription :: Monad m => GameStateM m String

-- | Check whetever the given <a>Condition</a>, indexed by <a>CondType</a>
--   and <a>CondId</a>, is true in current state of a game.
checkCondition :: Monad m => CondKey -> GameStateM m Bool

-- | The same as with <a>checkCondition</a> but you can provide what values
--   should be returned on result
--   
--   <pre>
--   checkConditionWith (cl, id) trueValue falseValue
--   </pre>
checkConditionWith :: Monad m => CondKey -> a -> a -> GameStateM m a

-- | The same as with <a>checkConditionWith</a> but in Monad version.
--   
--   <pre>
--   checkConditionWithM (cl, id) (Just truValue) Nothing
--   </pre>
checkConditionWithM :: Monad m => CondKey -> GameStateM m a -> GameStateM m a -> GameStateM m a
type GameStatus = (PlayerStatus, WorldStatus)

-- | Information about player
--   
--   <ul>
--   <li><i><tt>LocationP</tt></i> Current location of the player.</li>
--   <li><i><tt>ItemSet</tt></i> Items carry on by the player.</li>
--   </ul>
data PlayerStatus
PlayerStatus :: LocationP -> ItemSet -> PlayerStatus

-- | Check whether the player has the item.
psItemExists :: PlayerStatus -> Item -> Bool
type WorldStatus = (GameOptions, LocMap)
data GameOptions
GameOptions :: String -> String -> Int -> LocName -> Conditions -> String -> String -> GameOptions
[goGameName] :: GameOptions -> String
[goGameVersion] :: GameOptions -> String

-- | Define how many items can player can have.
[goPlayerCapacity] :: GameOptions -> Int

-- | Define in which location the game will end.
[goEndingLocation] :: GameOptions -> LocName

-- | Global conditions. They apply to every location in the game.
[goConditions] :: GameOptions -> Conditions

-- | Introduction text when a player starts a new game.
[goIntro] :: GameOptions -> String

-- | Outro text when a player finishes a game.
[goOutro] :: GameOptions -> String

-- | Get a global condition from the game options by its Id.
goCondition :: GameOptions -> CondId -> Condition

-- | Data providing all necessary information about location.
data Location
Location :: DescMap -> TravelMap -> ObjectSet -> ItemSet -> Actions -> Conditions -> Location
[lcDescList] :: Location -> DescMap
[lcTravelList] :: Location -> TravelMap
[lcObjects] :: Location -> ObjectSet
[lcItems] :: Location -> ItemSet
[lcActions] :: Location -> Actions
[lcConditions] :: Location -> Conditions

-- | LocName is the key of the <a>Location</a> data
newtype LocName
LocName :: String -> LocName
type LocationP = (LocName, Location)
type LocMap = Map LocName Location
type DescMap = (Map DescOrder LocDesc)
type TravelMap = (Map LocName LocCanTravel)

-- | Adding items to the given location.
lcAddItems :: [Item] -> LocationP -> LocationP

-- | Removing objects from the given location.
lcRemoveObjects :: [Object] -> LocationP -> LocationP

-- | Removing an item from the given location.
lcRemoveItem :: Item -> LocationP -> LocationP

-- | Check whether the item exists in the given location.
lcItemExists :: LocationP -> Item -> Bool

-- | Check whether the object exists in the given location.
lcObjExists :: LocationP -> Object -> Bool

-- | Take a condition from the location by its Id. Throws exception when
--   there is no such condition.
lcCondition :: LocationP -> CondId -> Condition

-- | Data type that has two constructors: a simple description
--   <a>LocDesc</a> or description displayed only under some condition
--   <a>LocDescCond</a>.
--   
--   It is a data type for a <a>Location</a> description.
data LocDesc
LocDesc :: String -> LocDesc
LocDescCond :: CondType -> CondId -> String -> LocDesc

-- | Unique key for ordering the description on the screen.
newtype DescOrder
DescOrder :: Int -> DescOrder

-- | Data type used to determine whether a player can travel to a location
--   availible in a current location.
--   
--   <a>LocCanTravel</a> - there is no restraints to travel.
--   <a>LocCannotTravel</a> - there is some condition to be met before you
--   can travel.
data LocCanTravel
LocCannotTravel :: CondType -> CondId -> String -> LocCanTravel
LocCanTravel :: LocCanTravel

-- | The <a>Condition</a> type stores information about all conditions that
--   need to be satisfied.
--   
--   Can have empty parameters.
data Condition
Condition :: ObjectsNotExist -> ItemsInLocation -> PlayerHasItems -> Condition

-- | the Enum data to determine whether condition apply only in a location
--   or it is a global condition that can be applied everywhere during the
--   game.
data CondType
CondLocal :: CondType
CondGlobal :: CondType

-- | An unique Id of a condition. Uniquness works separately for each
--   location and for globals ones; in other words two location can have
--   conditions with the same Ids.
newtype CondId
CondId :: Int -> CondId
type CondKey = (CondType, CondId)
type Conditions = (Map CondId Condition)
type ObjectsNotExist = [Object]
type ItemsInLocation = [Item]
type PlayerHasItems = [Item]

-- | Action data.
data Action

-- | Action of using items on some object.
ActionUseItemsOnObject :: ItemSet -> Object -> String -> [ActionResult] -> Action
[aItemsUsed] :: Action -> ItemSet
[aObject] :: Action -> Object
[aComment] :: Action -> String
[aResults] :: Action -> [ActionResult]

-- | Action of doing unique command on some object or without an object.
ActionUnique :: [String] -> Maybe Object -> String -> [ActionResult] -> Action
[auCommands] :: Action -> [String]
[aObjectM] :: Action -> Maybe Object
[aComment] :: Action -> String
[aResults] :: Action -> [ActionResult]
type Actions = [Action]

-- | Information about results of some Action.
--   
--   <ul>
--   <li><i><tt>ArAddLocationItems</tt></i> - After an action items will be
--   added to a location.</li>
--   <li><i><tt>ArRemoveObjects</tt></i> - After an action objects will be
--   removed from a location.</li>
--   </ul>
data ActionResult
ArAddLocationItems :: [Item] -> ActionResult
ArRemoveObjects :: [Object] -> ActionResult

-- | Check whether the given action is an <tt>UniqueAction</tt>.
isUniqeAction :: String -> Maybe Object -> Action -> Bool

-- | Check whether the given action is an <tt>ItemsOnObjectAction</tt>.
isItemsOnObjectAction :: Set Item -> Object -> Action -> Bool
newtype Item
Item :: String -> Item
newtype Object
Object :: String -> Object
type ItemSet = Set Item
type ObjectSet = Set Object

-- | Convert '[String]' to an <a>ItemSet</a>. Does not do any checks
--   whether those items exists in a game.
itemSetFromList :: [String] -> ItemSet
instance GHC.Read.Read Game.GameState.PlayerStatus
instance GHC.Show.Show Game.GameState.PlayerStatus
instance GHC.Read.Read Game.GameState.Location
instance GHC.Show.Show Game.GameState.Location
instance GHC.Read.Read Game.GameState.Action
instance GHC.Show.Show Game.GameState.Action
instance GHC.Read.Read Game.GameState.GameOptions
instance GHC.Show.Show Game.GameState.GameOptions
instance GHC.Read.Read Game.GameState.Condition
instance GHC.Show.Show Game.GameState.Condition
instance GHC.Read.Read Game.GameState.ActionResult
instance GHC.Show.Show Game.GameState.ActionResult
instance GHC.Read.Read Game.GameState.Object
instance GHC.Show.Show Game.GameState.Object
instance GHC.Classes.Ord Game.GameState.Object
instance GHC.Classes.Eq Game.GameState.Object
instance GHC.Read.Read Game.GameState.Item
instance GHC.Show.Show Game.GameState.Item
instance GHC.Classes.Ord Game.GameState.Item
instance GHC.Classes.Eq Game.GameState.Item
instance GHC.Read.Read Game.GameState.LocDesc
instance GHC.Show.Show Game.GameState.LocDesc
instance GHC.Read.Read Game.GameState.LocCanTravel
instance GHC.Show.Show Game.GameState.LocCanTravel
instance GHC.Read.Read Game.GameState.CondId
instance GHC.Classes.Ord Game.GameState.CondId
instance GHC.Classes.Eq Game.GameState.CondId
instance GHC.Show.Show Game.GameState.CondId
instance GHC.Read.Read Game.GameState.CondType
instance GHC.Show.Show Game.GameState.CondType
instance GHC.Read.Read Game.GameState.DescOrder
instance GHC.Classes.Ord Game.GameState.DescOrder
instance GHC.Classes.Eq Game.GameState.DescOrder
instance GHC.Show.Show Game.GameState.DescOrder
instance GHC.Read.Read Game.GameState.LocName
instance GHC.Show.Show Game.GameState.LocName
instance GHC.Classes.Ord Game.GameState.LocName
instance GHC.Classes.Eq Game.GameState.LocName
instance Game.RealShow.RealShow Game.GameState.Object
instance Game.RealShow.RealShow Game.GameState.Item
instance Game.RealShow.RealShow Game.GameState.LocName


-- | This module provides Commands data and the mean to parse it from a
--   string.
module Game.Command

-- | Parse the given string to a <a>Command</a>.
--   
--   <tt>[]</tt> are used to show alternative commands, <tt>{}</tt> are
--   used to show what a player can write in.
--   
--   <a>Travel</a>:
--   
--   <pre>
--   [go to\travel to\move to\gt] {locationName}
--   ex. go to Old House
--   </pre>
--   
--   <a>ItemsOnObject</a>:
--   
--   <pre>
--   [use items\ui] '{item},{item2},...' on {object name}
--   ex. ui <tt>Axe</tt> on New Door
--   </pre>
--   
--   <a>UniqueCommand</a>:
--   
--   <pre>
--   {command} [on// ] {object name}
--   {command}
--   ex. paint New Door
--   ex. super not useful command
--   </pre>
--   
--   <a>CheckBp</a>:
--   
--   <pre>
--   [check bp/<i>check backpack</i>/cbp]
--   </pre>
--   
--   <a>ExitGame</a>:
--   
--   <pre>
--   [:exit//:q]
--   </pre>
--   
--   <a>ExitAndSave</a>:
--   
--   <pre>
--   [:exitSave//:qs]
--   </pre>
--   
--   <a>Help</a>:
--   
--   <pre>
--   [:help//:h]
--   </pre>
--   
--   <a>PickUpItem</a>:
--   
--   <pre>
--   [pick up//pup] {item name}
--   ex. pup Fantastic Sword
--   </pre>
--   
--   <a>ThrowItem</a>:
--   
--   <pre>
--   [throw item//thri] {item name}
--   ex. thri Fantastic Sword
--   </pre>
parseCommand :: String -> Either ParseError Command

-- | Available commands in a game.
data Command
Travel :: LocName -> Command
ItemsOnObject :: Set Item -> Object -> Command
UniqueCommand :: String -> Maybe Object -> Command
CheckBp :: Command
PickUpItem :: Item -> Command
ThrowItem :: Item -> Command
ExitGame :: Command
ExitAndSave :: Command
Help :: Command
instance GHC.Show.Show Game.Command.Command


module Game.CommandHandler

-- | A data type is used to communicate the result, when exiting the game.
data ExitCode

-- | A player quits game without saving it.
QuitGame :: ExitCode

-- | A player quits game with saving it.
QuitAndSave :: ExitCode

-- | A player won the game.
PlayerWin :: ExitCode

-- | The core of the game logic. Basing on the received <a>Command</a> from
--   the player it manipulates the GameState.
--   
--   If the game has been finished, regardles of the reason, it will end up
--   in the Left state with <a>ExitCode</a>.
--   
--   Otherwise it will just return a string as a result message after
--   handling a particular command.
handleCommand :: Command -> GameStateM (Either ExitCode) String
instance GHC.Show.Show Game.CommandHandler.ExitCode


-- | Here we can find the game loop logic.
module Game.Runner

-- | Run the game. If true it will show the game's introduction text. When
--   false it will go straight to the <a>gameLoop</a>
runGame :: Bool -> GameStateIO ()

-- | Game loop handle interactions between the player and the game.
--   
--   Provides logic for handling quitting the current game, by handling the
--   <a>ExitCode</a> from the <tt>handleCommand'</tt>s <a>Left</a> result.
gameLoop :: GameStateIO ()

module Parser.Errors
type LoaderError = String


module Parser.Text.Language

-- | Parse many elements in a section <tt><a>{many parser} n /</a></tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   sectionMany <a>TokenName</a> (spaces *&gt; string "bb" &lt;* spaces) will parse:
--   &lt;TokenName
--       bb bb bb 
--       bb
--   /&gt;
--   </pre>
sectionMany :: String -> CharParser () a -> CharParser () [a]
sectionManyWithKey :: String -> CharParser () a -> CharParser () key -> CharParser () (key, [a])
sectionWithKey :: String -> CharParser () a -> CharParser () key -> CharParser () (key, a)
section :: String -> CharParser () a -> CharParser () a
inlineSection :: String -> CharParser () [String]
beginToken :: String -> CharParser () ()
tryEndToken :: CharParser () String
endToken :: CharParser () String
skipOptionName :: String -> CharParser () ()
readOption :: String -> CharParser () String
quotaString :: CharParser () String
readValueName :: CharParser () String
tryOptionInt :: String -> CharParser () Int
readOptionInt :: String -> CharParser () Int
readInt :: CharParser () Int
string' :: String -> CharParser () ()
tupple :: a -> b -> (a, b)
tryToTV :: (b -> c) -> a -> CharParser () b -> CharParser () (a, c)
choiceToTV :: [(a, CharParser () c)] -> CharParser () (a, c)

module Parser.Text.Option
class OptionInt a
getIntM :: OptionInt a => a -> Maybe Int
getInt :: OptionInt a => a -> Int
class OptionStr a
getStrM :: OptionStr a => a -> Maybe String
getStr :: OptionStr a => a -> String
class OptionArrStr a
getArrStrM :: OptionArrStr a => a -> Maybe [String]
getArrStr :: OptionArrStr a => a -> [String]
sGet :: (Ord k, Show k, OptionStr o) => Map k o -> k -> Either LoaderError String
saGet :: (Ord k, Show k, OptionArrStr o) => Map k o -> k -> Either LoaderError [String]
iGet :: (Ord k, Show k, OptionInt o) => Map k o -> k -> Either LoaderError Int
tGet :: (Ord k, Show k) => Map k o -> k -> (o -> b) -> Either LoaderError b
saGetD :: (Ord k, Show k, OptionArrStr o) => Map k o -> k -> (String -> b) -> [b]
errO :: Show a => a -> Either LoaderError b

module Parser.Text.Tokens
type IntroText = String
type OutroText = String
data GameOptionType
GameName :: GameOptionType
GameVersion :: GameOptionType
PlayerCapacity :: GameOptionType
StartingLocation :: GameOptionType
EndingLocation :: GameOptionType
data GameOption
GameOptionString :: String -> GameOption
GameOptionInt :: Int -> GameOption
type GameOptions = Map GameOptionType GameOption
data CondType
Local :: CondId -> CondType
Global :: CondId -> CondType
None :: CondType
type CondId = Int
data LocDesc
LocDesc :: CondType -> String -> LocDesc
data LocTravel
LocCannotTravel :: CondType -> String -> LocTravel
LocCanTravel :: LocTravel
type Action = Map ActionOptionType ActionOption
data ActionOptionType
AotType :: ActionOptionType
AotUsedItems :: ActionOptionType
AotUsedOn :: ActionOptionType
AotAddItemsToLocation :: ActionOptionType
AotComment :: ActionOptionType
AotObjectsRemove :: ActionOptionType
AotCommands :: ActionOptionType
data ActionOption
AoArrString :: [String] -> ActionOption
AoString :: String -> ActionOption
type Condition = Map ConditionOptionType ConditionOption
type Conditions = Map Int Condition
data ConditionOptionType
CotObjectsNotExist :: ConditionOptionType
CotItemsInLocation :: ConditionOptionType
CotPlayerItems :: ConditionOptionType
data ConditionOption
CoArrString :: [String] -> ConditionOption
type LocNameStr = String
data LocationOptionType
LocDescList :: LocationOptionType
LocTravelList :: LocationOptionType
LocObjects :: LocationOptionType
LocItems :: LocationOptionType
LocActions :: LocationOptionType
LocCond :: LocationOptionType
data LocationOption
LocDescListV :: Map Int LocDesc -> LocationOption
LocTravelListV :: Map String LocTravel -> LocationOption
LocStrings :: [String] -> LocationOption
LocActionsV :: [Action] -> LocationOption
LocCondV :: Map Int Condition -> LocationOption
type Location = Map LocationOptionType LocationOption
type LocMap = Map LocNameStr Location
data DataType
IntType :: DataType
StringType :: DataType
instance GHC.Show.Show Parser.Text.Tokens.DataType
instance GHC.Show.Show Parser.Text.Tokens.LocationOption
instance GHC.Classes.Ord Parser.Text.Tokens.LocationOptionType
instance GHC.Classes.Eq Parser.Text.Tokens.LocationOptionType
instance GHC.Show.Show Parser.Text.Tokens.LocationOptionType
instance GHC.Show.Show Parser.Text.Tokens.ConditionOption
instance GHC.Classes.Ord Parser.Text.Tokens.ConditionOptionType
instance GHC.Classes.Eq Parser.Text.Tokens.ConditionOptionType
instance GHC.Show.Show Parser.Text.Tokens.ConditionOptionType
instance GHC.Show.Show Parser.Text.Tokens.ActionOption
instance GHC.Classes.Ord Parser.Text.Tokens.ActionOptionType
instance GHC.Classes.Eq Parser.Text.Tokens.ActionOptionType
instance GHC.Show.Show Parser.Text.Tokens.ActionOptionType
instance GHC.Show.Show Parser.Text.Tokens.LocTravel
instance GHC.Show.Show Parser.Text.Tokens.LocDesc
instance GHC.Show.Show Parser.Text.Tokens.CondType
instance GHC.Show.Show Parser.Text.Tokens.GameOption
instance GHC.Classes.Ord Parser.Text.Tokens.GameOptionType
instance GHC.Classes.Eq Parser.Text.Tokens.GameOptionType
instance GHC.Show.Show Parser.Text.Tokens.GameOptionType
instance Parser.Text.Option.OptionArrStr Parser.Text.Tokens.LocationOption
instance Parser.Text.Option.OptionArrStr Parser.Text.Tokens.ConditionOption
instance Parser.Text.Option.OptionStr Parser.Text.Tokens.ActionOption
instance Parser.Text.Option.OptionArrStr Parser.Text.Tokens.ActionOption
instance Parser.Text.Option.OptionStr Parser.Text.Tokens.GameOption
instance Parser.Text.Option.OptionInt Parser.Text.Tokens.GameOption

module Parser.Text.Condition
readCond :: CharParser () CondType
readCondN :: String -> CharParser () CondType
readCondsSection :: CharParser () Conditions

module Parser.Text.Location
locationsSection :: CharParser () LocMap

module Parser.Text.Parser
parseGameFile :: String -> Either ParseError ParsingResult


module Parser.Game.Travel

-- | Converts '(T.LocNameStr, T.LocTravel)' to '(G.LocName,
--   G.LocCanTravel)'. Get the <a>LocMap</a> tokens and the name of the
--   location to performs consistency check.
travel :: LocMap -> LocNameStr -> (LocNameStr, LocTravel) -> Either LoaderError (LocName, LocCanTravel)


module Parser.Game.Condition

-- | Converts '(T.CondId, T.Condition)' to '(G.CondId, G.Condition)'
condition :: (CondId, Condition) -> (CondId, Condition)

-- | Converts 'T.Conditions ' to <a>Conditions</a>
conditionsLoader :: Conditions -> Conditions


module Parser.Game.Action

-- | Converts <a>Action</a> to <a>Action</a>. Performs simple check whether
--   the given token is correct. If isn't <a>LoaderError</a> is returned.
action :: Action -> Either LoaderError Action


module Parser.Game.Location

-- | Converts from '(T.LocNameStr, T.Location)' to the '(G.LocName,
--   G.Location)'. Get the <a>LocMap</a> to perform consistency checks.
location :: LocMap -> (LocNameStr, Location) -> Either LoaderError (LocName, Location)

module Parser.Loader
loadGame :: String -> Either LoaderError GameStatus


-- | It does what it says - interactive menu with an user. You can start
--   new game or load a saved one. Saved game has extension
--   <tt>.save.ste</tt>.
--   
--   New game has extension <tt>.game.ste</tt>
module MainMenu
mainMenu :: IO ()
